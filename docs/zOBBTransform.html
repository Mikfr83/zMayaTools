<html>
<head>
<link rel=stylesheet href=style.css>
<title>zOBBTransform - zMayaTools</title>

<body>
<div class=header>
    <a class=main-page-link href=index.html>zMayaTools</a>
    <a class=download-link href=https://github.com/zewt/zMayaTools/releases>download</a>
    <a class=github-link href=https://github.com/zewt/zMayaTools>github</a>
</div>

<h1>
    zOBBTransform
    <br>
    <span class=header-module>Module: <span class=module>zOBBTransform</span></span>
</h1>

<h2>Introduction</h2>
Extract translation, rotation and scale changes from a mesh.
<p>
This plugin connects to an original mesh and a changed mesh, and outputs TRS attributes
that approximate the transform being applied to the changed mesh compared to the original
mesh by comparing their OBBs.  This gives a transform that can be used to follow a mesh
around as it's deformed.
<p>
Geometry constraints only stick a transform to a point; this will approximate rotation
and scale as well.
<p>
The input and target mesh must have the same number of vertices.  Input meshes may come
through a groupParts to examine only a small subset of a mesh.
<p>
This currently has a native component to perform the OBB calculation.  This is not
a performance-critical part of the code since it's only performed on a 3x3 matrix,
and this dependency could be eliminated with something like this:
<a href=https://github.com/chrisdevito/OBB>OBB</a>
<p>
Conversely, this is fairly slow due to manipulating vertex data in Python.  Doing that
part in native code would be a lot faster.

<h2>Notes</h2>

This works best on irregular shapes.  If it's used on a regular shape like a sphere or
a cube, there are many possible orientations that will give the same bounding box and
the orientation can't be determined from just the vertex positions.

<h2>Binary plugin source</h2>

The source to the binary plugin is available on
[GitHub](https://github.com/zewt/zOBBTransformNative).  This repository only contains
a prebuilt Windows binary to keep the repository small.

